---
title: "stat293_project"
output: pdf_document
date: "2025-11-25"
---

## 8*8 Matrix with higher low series (T = 200)
```{r, fig.width=8, fig.height=6}
library(MASS)

generate_multi_var <- function(
    K=8, d=8, T=200,
    prop_common = 0.30,       # overall density of common matrix
    prop_unique = 0.10,       # unique deviation level
    min_edges_per_row = 2     # minimum edges per row
){

  # ==============================
  # 1) Generate True Group Common Matrix
  # ==============================
  B_common <- matrix(0, d, d)

  # Step 1: Each row has at least min_edges_per_row non-zeros
  for (i in 1:d) {
    cols <- sample(1:d, min_edges_per_row)
    B_common[i, cols] <- runif(min_edges_per_row, 0.3, 0.8)
  }

  # Step 2: Add extra edges according to prop_common
  total_target_nz <- floor(prop_common * d * d)
  current_nz <- sum(B_common != 0)

  if (current_nz < total_target_nz) {
    extra_needed <- total_target_nz - current_nz
    zero_pos <- which(B_common == 0)
    add_pos <- sample(zero_pos, extra_needed)
    B_common[add_pos] <- runif(extra_needed, 0.3, 0.8)
  }

  # Stabilize VAR
  eg <- max(abs(eigen(B_common)$values))
  if (eg >= 1) B_common <- B_common / (eg + 0.1)


  # ==============================
  # 2) Individual Level Dynamics
  # ==============================
  B_unique <- B_total <- series <- vector("list", K)

  for(k in 1:K){

    Bu <- matrix(0, d, d)
    nz_u <- sample(d*d, floor(prop_unique*d*d))
    Bu[nz_u] <- runif(length(nz_u), 0.2, 0.6)

    Bk <- B_common + Bu

    eg2 <- max(abs(eigen(Bk)$values))
    if (eg2 >= 1) Bk <- Bk/(eg2 + 0.1)

    B_unique[[k]] <- Bu
    B_total[[k]]  <- Bk

    # Generate time series
    X <- matrix(0, T, d)
    X[1,] <- rnorm(d)
    for(t in 2:T)
      X[t,] <- X[t-1,] %*% t(Bk) + rnorm(d,0,0.1)
    series[[k]] <- X
  }

  list(
    data     = series,
    B_common = B_common,
    B_unique = B_unique,
    B_total  = B_total
  )
}

# try more edges + stronger effect so heatmaps show clear pattern

sim <- generate_multi_var(
  K = 15,           # more subjects
  d = 8,            # keep dimension
  T = 200,          # shorter series
  prop_common = 0.35,
  prop_unique = 0.05,  # weaker individual noise
  min_edges_per_row = 3
)

dim(sim$B_common)
row_nz <- apply(sim$B_common != 0, 1, sum)
row_nz

# Helper function to plot matrices as heatmaps
plot_common_matrix <- function(M, title="Common Matrix") {
  library(ggplot2)
  library(reshape2)
  
  # Ensure M is a plain numeric matrix with no row/col names
  M <- as.matrix(M)
  rownames(M) <- NULL
  colnames(M) <- NULL
  
  df <- melt(M)
  colnames(df) <- c("Row", "Col", "Value")
  
  # Ensure Row and Col are numeric
  df$Row <- as.numeric(df$Row)
  df$Col <- as.numeric(df$Col)
  df$Value <- as.numeric(df$Value)

  ggplot(df, aes(x=Col, y=Row, fill=Value)) +
    geom_tile(color="grey50") +
    scale_fill_gradient2(low="red", mid="white", high="blue", midpoint=0) +
    scale_x_continuous(breaks=1:ncol(M)) +
    scale_y_reverse(breaks=1:nrow(M)) +
    labs(title=title, x="From", y="To") +
    theme_minimal(base_size=12) +
    theme(aspect.ratio = 1)
}

plot_common_matrix(sim$B_common,"Normalized TRUE Common Matrix")

```


```{r, fig.width=12, fig.height=6}

library(multivar)  
library(ggplot2)
library(gridExtra)

t1 <- 60      # start of CV region
t2 <- 120     # end of CV region (= last index used in CV)

model <- constructModel(
  data        = sim$data,
  lag         = 1,
  t1          = t1,
  t2          = t2,
  cv          = "blocked",
  nfolds      = 5,
  lassotype   = "adaptive",
  standardize = TRUE
)

fit <- cv.multivar(model)

## -------------------------------------------------
## 3) Inspect fit structure to find correct slot names
## -------------------------------------------------

# Print the structure to see available slots
cat("Structure of fit object:\n")
print(names(fit))

# The multivar package typically stores results in these slots:
# - fit$common or fit$Phi (for the common matrix)
# - fit$Phi_total or fit$total (for subject-specific total matrices)
# Check your specific version

## -------------------------------------------------
## 4) TRUE vs ESTIMATED: group-level (common) matrix
## -------------------------------------------------

true_common_mat <- sim$B_common    # Ground truth

# Check structure of fit$mats
cat("Elements in fit$mats:\n")
print(names(fit$mats))

# Extract estimated common matrix from fit$mats
# Typically named 'common', 'Phi', or 'group'
if ("common" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$common
} else if ("Phi" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$Phi
} else if ("group" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$group
} else {
  # Show what's available
  cat("\nStructure of fit$mats:\n")
  str(fit$mats, max.level = 1)
  # Try first element as fallback
  est_common_mat <- fit$mats[[1]]
  cat("\nUsing first element of fit$mats as common matrix\n")
}

# Debug: Check what we extracted
cat("\n--- Debugging est_common_mat ---\n")
cat("Class:", class(est_common_mat), "\n")
cat("Dimensions:", dim(est_common_mat), "\n")
cat("Is matrix?:", is.matrix(est_common_mat), "\n")
if (!is.null(est_common_mat)) {
  cat("First few values:", head(as.vector(est_common_mat)), "\n")
  cat("Any NA?:", any(is.na(est_common_mat)), "\n")
  cat("Any Inf?:", any(is.infinite(est_common_mat)), "\n")
}

# If est_common_mat is a list, try to extract the matrix
if (is.list(est_common_mat) && !is.matrix(est_common_mat)) {
  cat("\nest_common_mat is a list, checking contents:\n")
  str(est_common_mat, max.level = 1)
  # Try to get first element if it's a matrix
  if (length(est_common_mat) > 0 && is.matrix(est_common_mat[[1]])) {
    est_common_mat <- est_common_mat[[1]]
    cat("Extracted matrix from list\n")
  }
}

# Ensure it's a proper matrix with correct dimensions
if (!is.matrix(est_common_mat) || !all(dim(est_common_mat) == dim(true_common_mat))) {
  cat("\nWARNING: est_common_mat dimensions don't match true_common_mat\n")
  cat("true_common_mat dims:", dim(true_common_mat), "\n")
  cat("est_common_mat dims:", dim(est_common_mat), "\n")
}

# Plot TRUE vs ESTIMATED common matrix side by side
p_true_common <- plot_common_matrix(true_common_mat, "TRUE Common Matrix")

if (is.matrix(est_common_mat) && all(dim(est_common_mat) == dim(true_common_mat))) {
  p_est_common <- plot_common_matrix(est_common_mat, "ESTIMATED Common Matrix")
  
  # Use patchwork instead of grid.arrange (more reliable)
  library(patchwork)
  print(p_true_common + p_est_common)
} else {
  cat("\nCannot plot est_common_mat - printing structure instead:\n")
  str(fit$mats)
  print(p_true_common)
}

## -------------------------------------------------
## 5) TRUE vs ESTIMATED: subject-specific total matrices
## -------------------------------------------------

library(patchwork)

d <- nrow(sim$B_common)

g_list <- list()
idx <- 1

# Extract estimated total matrices from fit$mats
if ("total" %in% names(fit$mats)) {
  est_total_list <- fit$mats$total
} else if ("subject" %in% names(fit$mats)) {
  est_total_list <- fit$mats$subject
} else if ("individual" %in% names(fit$mats)) {
  est_total_list <- fit$mats$individual
} else {
  cat("\nElements in fit$mats:\n")
  str(fit$mats, max.level = 1)
  # Try to find the list element that contains subject matrices
  for (nm in names(fit$mats)) {
    if (is.list(fit$mats[[nm]]) && length(fit$mats[[nm]]) >= 3) {
      est_total_list <- fit$mats[[nm]]
      cat(sprintf("\nUsing fit$mats$%s as total matrices list\n", nm))
      break
    }
  }
}

for (k in 1:3) {
  true_total_k <- sim$B_total[[k]]
  est_total_k  <- est_total_list[[k]]

  p_true <- plot_common_matrix(true_total_k, paste("TRUE Total – Subject", k))
  p_est  <- plot_common_matrix(est_total_k,  paste("EST Total – Subject",  k))

  g_list[[idx]]     <- p_true
  g_list[[idx + 1]] <- p_est
  idx <- idx + 2
}

# Display plots
wrap_plots(g_list, ncol = 2)

## -------------------------------------------------
## 6) Compute error metrics
## -------------------------------------------------

# Frobenius norm error for common matrix
common_error_F <- norm(true_common_mat - est_common_mat, type = "F")
cat("\nCommon Matrix Frobenius Error:", common_error_F, "\n")

# Subject-level errors
cat("\nSubject-level Total Matrix Frobenius Errors:\n")
for (k in 1:length(sim$B_total)) {
  true_total_k <- sim$B_total[[k]]
  est_total_k  <- est_total_list[[k]]
  total_error_kF <- norm(true_total_k - est_total_k, type = "F")
  cat(sprintf("  Subject %d: %.4f\n", k, total_error_kF))
}
```

## 8*8 Matrix with higher time series (T = 500)
```{r, fig.width=8, fig.height=6}
library(MASS)

generate_multi_var <- function(
    K=8, d=8, T=200,
    prop_common = 0.30,       # overall density of common matrix
    prop_unique = 0.10,       # unique deviation level
    min_edges_per_row = 2     # minimum edges per row
){

  # ==============================
  # 1) Generate True Group Common Matrix
  # ==============================
  B_common <- matrix(0, d, d)

  # Step 1: Each row has at least min_edges_per_row non-zeros
  for (i in 1:d) {
    cols <- sample(1:d, min_edges_per_row)
    B_common[i, cols] <- runif(min_edges_per_row, 0.3, 0.8)
  }

  # Step 2: Add extra edges according to prop_common
  total_target_nz <- floor(prop_common * d * d)
  current_nz <- sum(B_common != 0)

  if (current_nz < total_target_nz) {
    extra_needed <- total_target_nz - current_nz
    zero_pos <- which(B_common == 0)
    add_pos <- sample(zero_pos, extra_needed)
    B_common[add_pos] <- runif(extra_needed, 0.3, 0.8)
  }

  # Stabilize VAR
  eg <- max(abs(eigen(B_common)$values))
  if (eg >= 1) B_common <- B_common / (eg + 0.1)


  # ==============================
  # 2) Individual Level Dynamics
  # ==============================
  B_unique <- B_total <- series <- vector("list", K)

  for(k in 1:K){

    Bu <- matrix(0, d, d)
    nz_u <- sample(d*d, floor(prop_unique*d*d))
    Bu[nz_u] <- runif(length(nz_u), 0.2, 0.6)

    Bk <- B_common + Bu

    eg2 <- max(abs(eigen(Bk)$values))
    if (eg2 >= 1) Bk <- Bk/(eg2 + 0.1)

    B_unique[[k]] <- Bu
    B_total[[k]]  <- Bk

    # Generate time series
    X <- matrix(0, T, d)
    X[1,] <- rnorm(d)
    for(t in 2:T)
      X[t,] <- X[t-1,] %*% t(Bk) + rnorm(d,0,0.1)
    series[[k]] <- X
  }

  list(
    data     = series,
    B_common = B_common,
    B_unique = B_unique,
    B_total  = B_total
  )
}

# try more edges + stronger effect so heatmaps show clear pattern

sim <- generate_multi_var(
  K = 15,           # more subjects
  d = 8,            # keep dimension
  T = 500,          # longer series
  prop_common = 0.35,
  prop_unique = 0.05,  # weaker individual noise
  min_edges_per_row = 3
)

dim(sim$B_common)
row_nz <- apply(sim$B_common != 0, 1, sum)
row_nz

# Helper function to plot matrices as heatmaps
plot_common_matrix <- function(M, title="Common Matrix") {
  library(ggplot2)
  library(reshape2)
  
  # Ensure M is a plain numeric matrix with no row/col names
  M <- as.matrix(M)
  rownames(M) <- NULL
  colnames(M) <- NULL
  
  df <- melt(M)
  colnames(df) <- c("Row", "Col", "Value")
  
  # Ensure Row and Col are numeric
  df$Row <- as.numeric(df$Row)
  df$Col <- as.numeric(df$Col)
  df$Value <- as.numeric(df$Value)

  ggplot(df, aes(x=Col, y=Row, fill=Value)) +
    geom_tile(color="grey50") +
    scale_fill_gradient2(low="red", mid="white", high="blue", midpoint=0) +
    scale_x_continuous(breaks=1:ncol(M)) +
    scale_y_reverse(breaks=1:nrow(M)) +
    labs(title=title, x="From", y="To") +
    theme_minimal(base_size=12) +
    theme(aspect.ratio = 1)
}

plot_common_matrix(sim$B_common,"Normalized TRUE Common Matrix")

```


```{r, fig.width=12, fig.height=6}

library(multivar)  
library(ggplot2)
library(gridExtra)

t1 <- 60      # start of CV region
t2 <- 120     # end of CV region (= last index used in CV)

model <- constructModel(
  data        = sim$data,
  lag         = 1,
  t1          = t1,
  t2          = t2,
  cv          = "blocked",
  nfolds      = 5,
  lassotype   = "adaptive",
  standardize = TRUE
)

fit <- cv.multivar(model)

## -------------------------------------------------
## 3) Inspect fit structure to find correct slot names
## -------------------------------------------------

# Print the structure to see available slots
cat("Structure of fit object:\n")
print(names(fit))

# The multivar package typically stores results in these slots:
# - fit$common or fit$Phi (for the common matrix)
# - fit$Phi_total or fit$total (for subject-specific total matrices)
# Check your specific version

## -------------------------------------------------
## 4) TRUE vs ESTIMATED: group-level (common) matrix
## -------------------------------------------------

true_common_mat <- sim$B_common    # Ground truth

# Check structure of fit$mats
cat("Elements in fit$mats:\n")
print(names(fit$mats))

# Extract estimated common matrix from fit$mats
# Typically named 'common', 'Phi', or 'group'
if ("common" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$common
} else if ("Phi" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$Phi
} else if ("group" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$group
} else {
  # Show what's available
  cat("\nStructure of fit$mats:\n")
  str(fit$mats, max.level = 1)
  # Try first element as fallback
  est_common_mat <- fit$mats[[1]]
  cat("\nUsing first element of fit$mats as common matrix\n")
}

# Debug: Check what we extracted
cat("\n--- Debugging est_common_mat ---\n")
cat("Class:", class(est_common_mat), "\n")
cat("Dimensions:", dim(est_common_mat), "\n")
cat("Is matrix?:", is.matrix(est_common_mat), "\n")
if (!is.null(est_common_mat)) {
  cat("First few values:", head(as.vector(est_common_mat)), "\n")
  cat("Any NA?:", any(is.na(est_common_mat)), "\n")
  cat("Any Inf?:", any(is.infinite(est_common_mat)), "\n")
}

# If est_common_mat is a list, try to extract the matrix
if (is.list(est_common_mat) && !is.matrix(est_common_mat)) {
  cat("\nest_common_mat is a list, checking contents:\n")
  str(est_common_mat, max.level = 1)
  # Try to get first element if it's a matrix
  if (length(est_common_mat) > 0 && is.matrix(est_common_mat[[1]])) {
    est_common_mat <- est_common_mat[[1]]
    cat("Extracted matrix from list\n")
  }
}

# Ensure it's a proper matrix with correct dimensions
if (!is.matrix(est_common_mat) || !all(dim(est_common_mat) == dim(true_common_mat))) {
  cat("\nWARNING: est_common_mat dimensions don't match true_common_mat\n")
  cat("true_common_mat dims:", dim(true_common_mat), "\n")
  cat("est_common_mat dims:", dim(est_common_mat), "\n")
}

# Plot TRUE vs ESTIMATED common matrix side by side
p_true_common <- plot_common_matrix(true_common_mat, "TRUE Common Matrix")

if (is.matrix(est_common_mat) && all(dim(est_common_mat) == dim(true_common_mat))) {
  p_est_common <- plot_common_matrix(est_common_mat, "ESTIMATED Common Matrix")
  
  # Use patchwork instead of grid.arrange (more reliable)
  library(patchwork)
  print(p_true_common + p_est_common)
} else {
  cat("\nCannot plot est_common_mat - printing structure instead:\n")
  str(fit$mats)
  print(p_true_common)
}

## -------------------------------------------------
## 5) TRUE vs ESTIMATED: subject-specific total matrices
## -------------------------------------------------

library(patchwork)

d <- nrow(sim$B_common)

g_list <- list()
idx <- 1

# Extract estimated total matrices from fit$mats
if ("total" %in% names(fit$mats)) {
  est_total_list <- fit$mats$total
} else if ("subject" %in% names(fit$mats)) {
  est_total_list <- fit$mats$subject
} else if ("individual" %in% names(fit$mats)) {
  est_total_list <- fit$mats$individual
} else {
  cat("\nElements in fit$mats:\n")
  str(fit$mats, max.level = 1)
  # Try to find the list element that contains subject matrices
  for (nm in names(fit$mats)) {
    if (is.list(fit$mats[[nm]]) && length(fit$mats[[nm]]) >= 3) {
      est_total_list <- fit$mats[[nm]]
      cat(sprintf("\nUsing fit$mats$%s as total matrices list\n", nm))
      break
    }
  }
}

for (k in 1:3) {
  true_total_k <- sim$B_total[[k]]
  est_total_k  <- est_total_list[[k]]

  p_true <- plot_common_matrix(true_total_k, paste("TRUE Total – Subject", k))
  p_est  <- plot_common_matrix(est_total_k,  paste("EST Total – Subject",  k))

  g_list[[idx]]     <- p_true
  g_list[[idx + 1]] <- p_est
  idx <- idx + 2
}

# Display plots
wrap_plots(g_list, ncol = 2)

## -------------------------------------------------
## 6) Compute error metrics
## -------------------------------------------------

# Frobenius norm error for common matrix
common_error_F <- norm(true_common_mat - est_common_mat, type = "F")
cat("\nCommon Matrix Frobenius Error:", common_error_F, "\n")

# Subject-level errors
cat("\nSubject-level Total Matrix Frobenius Errors:\n")
for (k in 1:length(sim$B_total)) {
  true_total_k <- sim$B_total[[k]]
  est_total_k  <- est_total_list[[k]]
  total_error_kF <- norm(true_total_k - est_total_k, type = "F")
  cat(sprintf("  Subject %d: %.4f\n", k, total_error_kF))
}
```


## 10*10 Matrix with higher time series (T = 500)
```{r, fig.width=8, fig.height=6}
library(MASS)

generate_multi_var <- function(
    K=8, d=8, T=200,
    prop_common = 0.30,       # overall density of common matrix
    prop_unique = 0.10,       # unique deviation level
    min_edges_per_row = 2     # minimum edges per row
){

  # ==============================
  # 1) Generate True Group Common Matrix
  # ==============================
  B_common <- matrix(0, d, d)

  # Step 1: Each row has at least min_edges_per_row non-zeros
  for (i in 1:d) {
    cols <- sample(1:d, min_edges_per_row)
    B_common[i, cols] <- runif(min_edges_per_row, 0.3, 0.8)
  }

  # Step 2: Add extra edges according to prop_common
  total_target_nz <- floor(prop_common * d * d)
  current_nz <- sum(B_common != 0)

  if (current_nz < total_target_nz) {
    extra_needed <- total_target_nz - current_nz
    zero_pos <- which(B_common == 0)
    add_pos <- sample(zero_pos, extra_needed)
    B_common[add_pos] <- runif(extra_needed, 0.3, 0.8)
  }

  # Stabilize VAR
  eg <- max(abs(eigen(B_common)$values))
  if (eg >= 1) B_common <- B_common / (eg + 0.1)


  # ==============================
  # 2) Individual Level Dynamics
  # ==============================
  B_unique <- B_total <- series <- vector("list", K)

  for(k in 1:K){

    Bu <- matrix(0, d, d)
    nz_u <- sample(d*d, floor(prop_unique*d*d))
    Bu[nz_u] <- runif(length(nz_u), 0.2, 0.6)

    Bk <- B_common + Bu

    eg2 <- max(abs(eigen(Bk)$values))
    if (eg2 >= 1) Bk <- Bk/(eg2 + 0.1)

    B_unique[[k]] <- Bu
    B_total[[k]]  <- Bk

    # Generate time series
    X <- matrix(0, T, d)
    X[1,] <- rnorm(d)
    for(t in 2:T)
      X[t,] <- X[t-1,] %*% t(Bk) + rnorm(d,0,0.1)
    series[[k]] <- X
  }

  list(
    data     = series,
    B_common = B_common,
    B_unique = B_unique,
    B_total  = B_total
  )
}

# try more edges + stronger effect so heatmaps show clear pattern

sim <- generate_multi_var(
  K = 15,           # more subjects
  d = 10,            # keep dimension
  T = 500,          # longer series
  prop_common = 0.35,
  prop_unique = 0.05,  # weaker individual noise
  min_edges_per_row = 3
)

dim(sim$B_common)
row_nz <- apply(sim$B_common != 0, 1, sum)
row_nz

# Helper function to plot matrices as heatmaps
plot_common_matrix <- function(M, title="Common Matrix") {
  library(ggplot2)
  library(reshape2)
  
  # Ensure M is a plain numeric matrix with no row/col names
  M <- as.matrix(M)
  rownames(M) <- NULL
  colnames(M) <- NULL
  
  df <- melt(M)
  colnames(df) <- c("Row", "Col", "Value")
  
  # Ensure Row and Col are numeric
  df$Row <- as.numeric(df$Row)
  df$Col <- as.numeric(df$Col)
  df$Value <- as.numeric(df$Value)

  ggplot(df, aes(x=Col, y=Row, fill=Value)) +
    geom_tile(color="grey50") +
    scale_fill_gradient2(low="red", mid="white", high="blue", midpoint=0) +
    scale_x_continuous(breaks=1:ncol(M)) +
    scale_y_reverse(breaks=1:nrow(M)) +
    labs(title=title, x="From", y="To") +
    theme_minimal(base_size=12) +
    theme(aspect.ratio = 1)
}

plot_common_matrix(sim$B_common,"Normalized TRUE Common Matrix")

```


```{r, fig.width=12, fig.height=6}

library(multivar)  
library(ggplot2)
library(gridExtra)

t1 <- 60      # start of CV region
t2 <- 120     # end of CV region (= last index used in CV)

model <- constructModel(
  data        = sim$data,
  lag         = 1,
  t1          = t1,
  t2          = t2,
  cv          = "blocked",
  nfolds      = 5,
  lassotype   = "adaptive",
  standardize = TRUE
)

fit <- cv.multivar(model)

## -------------------------------------------------
## 3) Inspect fit structure to find correct slot names
## -------------------------------------------------

# Print the structure to see available slots
cat("Structure of fit object:\n")
print(names(fit))

# The multivar package typically stores results in these slots:
# - fit$common or fit$Phi (for the common matrix)
# - fit$Phi_total or fit$total (for subject-specific total matrices)
# Check your specific version

## -------------------------------------------------
## 4) TRUE vs ESTIMATED: group-level (common) matrix
## -------------------------------------------------

true_common_mat <- sim$B_common    # Ground truth

# Check structure of fit$mats
cat("Elements in fit$mats:\n")
print(names(fit$mats))

# Extract estimated common matrix from fit$mats
# Typically named 'common', 'Phi', or 'group'
if ("common" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$common
} else if ("Phi" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$Phi
} else if ("group" %in% names(fit$mats)) {
  est_common_mat <- fit$mats$group
} else {
  # Show what's available
  cat("\nStructure of fit$mats:\n")
  str(fit$mats, max.level = 1)
  # Try first element as fallback
  est_common_mat <- fit$mats[[1]]
  cat("\nUsing first element of fit$mats as common matrix\n")
}

# Debug: Check what we extracted
cat("\n--- Debugging est_common_mat ---\n")
cat("Class:", class(est_common_mat), "\n")
cat("Dimensions:", dim(est_common_mat), "\n")
cat("Is matrix?:", is.matrix(est_common_mat), "\n")
if (!is.null(est_common_mat)) {
  cat("First few values:", head(as.vector(est_common_mat)), "\n")
  cat("Any NA?:", any(is.na(est_common_mat)), "\n")
  cat("Any Inf?:", any(is.infinite(est_common_mat)), "\n")
}

# If est_common_mat is a list, try to extract the matrix
if (is.list(est_common_mat) && !is.matrix(est_common_mat)) {
  cat("\nest_common_mat is a list, checking contents:\n")
  str(est_common_mat, max.level = 1)
  # Try to get first element if it's a matrix
  if (length(est_common_mat) > 0 && is.matrix(est_common_mat[[1]])) {
    est_common_mat <- est_common_mat[[1]]
    cat("Extracted matrix from list\n")
  }
}

# Ensure it's a proper matrix with correct dimensions
if (!is.matrix(est_common_mat) || !all(dim(est_common_mat) == dim(true_common_mat))) {
  cat("\nWARNING: est_common_mat dimensions don't match true_common_mat\n")
  cat("true_common_mat dims:", dim(true_common_mat), "\n")
  cat("est_common_mat dims:", dim(est_common_mat), "\n")
}

# Plot TRUE vs ESTIMATED common matrix side by side
p_true_common <- plot_common_matrix(true_common_mat, "TRUE Common Matrix")

if (is.matrix(est_common_mat) && all(dim(est_common_mat) == dim(true_common_mat))) {
  p_est_common <- plot_common_matrix(est_common_mat, "ESTIMATED Common Matrix")
  
  # Use patchwork instead of grid.arrange (more reliable)
  library(patchwork)
  print(p_true_common + p_est_common)
} else {
  cat("\nCannot plot est_common_mat - printing structure instead:\n")
  str(fit$mats)
  print(p_true_common)
}

## -------------------------------------------------
## 5) TRUE vs ESTIMATED: subject-specific total matrices
## -------------------------------------------------

library(patchwork)

d <- nrow(sim$B_common)

g_list <- list()
idx <- 1

# Extract estimated total matrices from fit$mats
if ("total" %in% names(fit$mats)) {
  est_total_list <- fit$mats$total
} else if ("subject" %in% names(fit$mats)) {
  est_total_list <- fit$mats$subject
} else if ("individual" %in% names(fit$mats)) {
  est_total_list <- fit$mats$individual
} else {
  cat("\nElements in fit$mats:\n")
  str(fit$mats, max.level = 1)
  # Try to find the list element that contains subject matrices
  for (nm in names(fit$mats)) {
    if (is.list(fit$mats[[nm]]) && length(fit$mats[[nm]]) >= 3) {
      est_total_list <- fit$mats[[nm]]
      cat(sprintf("\nUsing fit$mats$%s as total matrices list\n", nm))
      break
    }
  }
}

for (k in 1:3) {
  true_total_k <- sim$B_total[[k]]
  est_total_k  <- est_total_list[[k]]

  p_true <- plot_common_matrix(true_total_k, paste("TRUE Total – Subject", k))
  p_est  <- plot_common_matrix(est_total_k,  paste("EST Total – Subject",  k))

  g_list[[idx]]     <- p_true
  g_list[[idx + 1]] <- p_est
  idx <- idx + 2
}

# Display plots
wrap_plots(g_list, ncol = 2)

## -------------------------------------------------
## 6) Compute error metrics
## -------------------------------------------------

# Frobenius norm error for common matrix
common_error_F <- norm(true_common_mat - est_common_mat, type = "F")
cat("\nCommon Matrix Frobenius Error:", common_error_F, "\n")

# Subject-level errors
cat("\nSubject-level Total Matrix Frobenius Errors:\n")
for (k in 1:length(sim$B_total)) {
  true_total_k <- sim$B_total[[k]]
  est_total_k  <- est_total_list[[k]]
  total_error_kF <- norm(true_total_k - est_total_k, type = "F")
  cat(sprintf("  Subject %d: %.4f\n", k, total_error_kF))
}
```





